## Facade Pattern
### 퍼사드 패턴이란? 
- 라이브러리 (또는 서브시스템)에 대해 사용하기 편한 인터페이스를 구성하기 위한 구조 패턴 
  - 라이브러리의 각 클래스와 메서드의 사용이 복잡, 바로 가져다 쓰기 어려울 때 
  - 구현 디테일은 내부로 묶고 사용자가 쓰기 쉽게 정리하는 것 
### 필요한 상황 
- 라이브러리의 여러 API를 조합해서 쓰는 상황에서 클라이언트의 코드의 라이브러리의 의존성이 심할 때 
- 복잡한 서브 시스템에 대한 제한적이지만 간단한 인터페이스가 필요할 때 

### 구조 
![img.png](Facade/FacadeStructure.png)

### 장점  
- 서브 시스템 간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모음 
- 클라이언트가 외부의 퍼사드 클래스만 다루기 때문에 기능을 쉽게 이해하고 사용할 수 있음 

### 단점 
- 앱의 모든 클래스에 결합된 god object가 될 수 있다. 
- 코드가 추가되어서 유지보수 측면에서 관리 대상이 늘어남 

## Flyweight Pattern
### 플라이 웨이트 패턴이란? 
- 메모리 사용량을 최소화하기 위해 _**재사용 가능한 객체를 공유할 수 있게**_ 해주는 구조 패턴 
  - _**캐시 (Cache)**_ 개념을 도입하여 패턴화 
  - 자주 변화하는 속성 (extrinsic)과 변하지 않는 속성(intrinsic)으로 분리 
  - 변하지 않는 속성은 캐시함 (따로 저장하고 재사용해 메모리를 아낌)

### 구조 
![img.png](Flyweight/FlyweightStructure.png)

### 사용 시기 
- _**메모리에 오래 상주하는 객체**_(Flyweight중 Cache)가 많이 생성되어 메모리 사용이 높을 때 
- ***공통적인 인스턴스(Flyweight)***를 많이 생성하는 로직이 포함되는 경우 

### 장점 
- 메모리 사용량과 프로그램 속도 개선 가능 
  - new 연산자 사용하여 객체 생성시 데이터 생성 및 메모리 적재에 시간이 소모 됨 
### 단점 
- 캐싱등을 처리하기 위한 클래스 도입(Flyweight Factory)으로 코드의 복잡성이 올라감 


## Proxy Pattern 